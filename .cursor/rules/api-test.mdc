---
glob: "**/*/api/*_test.go"
alwaysApply: false
---

# API Testing Guide - Cursor Rules

You are an expert in writing HTTP API tests in Go. Apply these rules consistently for all API test code.

## ⚠️ MANDATORY COMPLIANCE

**ALL RULES IN THIS GUIDE ARE MANDATORY AND MUST BE FOLLOWED WITHOUT EXCEPTION.**

This guide extends the general Go testing guide with API-specific patterns. Refer to `@go-testing-guide.mdc` for foundational testing practices.

## Test File Structure

### Package and Imports
```go
package api //nolint:testpackage // for test internal function

import (
    "bytes"
    "context"
    "errors"
    "flag"
    "fmt"
    "io"
    "log"
    "net/http"
    "net/http/httptest"
    "os"
    "testing"
    "time"

    "github.com/go-chi/chi/v5"
    "github.com/google/go-cmp/cmp"
    "github.com/google/go-cmp/cmp/cmpopts"
    "github.com/google/uuid"
    "go.uber.org/goleak"
    "go.uber.org/mock/gomock"

    "remora/internal/api/middleware"
    "remora/internal/domain"
    "remora/internal/domain/mocks"
    "remora/internal/httpwrap"
)
```

### Static Error Variables
Define static test errors at package level (see `@go-testing-guide.mdc`):
```go
var (
    errDatabase     = errors.New("database error")
    errEventPublish = errors.New("event publish error")
)
```

## Test Structure for API Handlers

### Handler Test Pattern
```go
func Test_handlerName(t *testing.T) {
    t.Parallel()

    // Test constants (IDs, etc.)
    userID := uuid.New()
    resourceID := uuid.New()

    tests := []struct {
        name        string
        setupReq    func() *http.Request
        setupSvc    func(ctrl *gomock.Controller) *mocks.MockService
        wantResp    *httpwrap.Response
        wantErrResp *httpwrap.ErrorResponse
    }{
        {
            name: "success",
            setupReq: func() *http.Request {
                // Create test request
            },
            setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
                // Setup mock service
            },
            wantResp: &httpwrap.Response{
                StatusCode: http.StatusOK,
                Body:       &ExpectedResponse{},
            },
        },
        // More test cases...
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()

            ctrl := gomock.NewController(t)
            req := tt.setupReq()
            
            gotResp, gotErrResp := handlerName(tt.setupSvc(ctrl))(req)

            // Assertions (see comparison section)
        })
    }
}
```

### Test Fields
- `name`: Test case name (follow go-testing-guide.mdc conventions)
- `setupReq`: Function that creates and configures `*http.Request`
- `setupSvc`: Function that creates mock service with expectations
- `wantResp`: Expected successful response (`*httpwrap.Response`)
- `wantErrResp`: Expected error response (`*httpwrap.ErrorResponse`)

**Important**: Only one of `wantResp` or `wantErrResp` should be non-nil per test case.

## HTTP Request Setup

### Simple Requests (No URL Parameters)
```go
setupReq: func() *http.Request {
    req := httptest.NewRequest(http.MethodGet, "/resources", nil)
    req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
    return req
}
```

### Requests with URL Parameters
Use helper function (see Helper Functions section):
```go
setupReq: func() *http.Request {
    req := createRequestWithURLParam(
        http.MethodGet,
        fmt.Sprintf("/resources/%s", resourceID.String()),
        resourceID.String(),
    )
    req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
    return req
}
```

### Requests with JSON Body
```go
setupReq: func() *http.Request {
    req := httptest.NewRequest(http.MethodPost, "/resources", nil)
    
    // Set JSON body
    req.Body = io.NopCloser(bytes.NewReader([]byte(`{
        "name": "test",
        "description": "test description",
        "tags": ["tag1", "tag2"]
    }`)))
    
    req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
    return req
}
```

### Requests with Multiple URL Parameters
Modify the helper to support multiple parameters:
```go
setupReq: func() *http.Request {
    req := httptest.NewRequest(
        http.MethodGet,
        fmt.Sprintf("/resources/%s/items/%s", resourceID.String(), itemID.String()),
        nil,
    )
    
    rctx := chi.NewRouteContext()
    rctx.URLParams.Add("resource_id", resourceID.String())
    rctx.URLParams.Add("item_id", itemID.String())
    req = req.WithContext(context.WithValue(req.Context(), chi.RouteCtxKey, rctx))
    
    return req
}
```

## Mock Service Setup

### Simple Mock Setup
```go
setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
    svc := mocks.NewMockService(ctrl)
    
    svc.EXPECT().
        GetResource(gomock.Any(), resourceID).
        Return(&domain.Resource{ID: resourceID, Name: "test"}, nil)
    
    return svc
}
```

### Mock with Specific Parameter Validation
```go
setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
    svc := mocks.NewMockService(ctrl)
    
    // Validate exact parameters
    svc.EXPECT().
        CreateResource(gomock.Any(), &domain.CreateParams{
            UserID: userID,
            Name:   "test",
        }).
        Return(&domain.Resource{ID: resourceID}, nil)
    
    return svc
}
```

### Mock with Custom Matcher
For complex parameter validation (e.g., dynamic fields like timestamps):
```go
setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
    svc := mocks.NewMockService(ctrl)
    
    // Use custom matcher for parameters that can't be exactly matched
    svc.EXPECT().
        CreateChannel(gomock.Any(), createChannelParamsMatcher{params: &channel.CreateChannelParams{
            UserID:      userID,
            Name:        "test",
            Icon:        "icon",
            Description: "description",
            Wallets:     []string{"address"},
        }}).
        Return(nil)
    
    return svc
}
```

### Mock with Multiple Calls
```go
setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
    svc := mocks.NewMockService(ctrl)
    
    // First call
    svc.EXPECT().
        ListResourcesByUserID(gomock.Any(), userID).
        Return([]*domain.Resource{}, nil)
    
    // Second call
    svc.EXPECT().
        CreateResource(gomock.Any(), gomock.Any()).
        Return(nil)
    
    return svc
}
```

### Mock Returning Errors
```go
setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
    svc := mocks.NewMockService(ctrl)
    
    svc.EXPECT().
        GetResource(gomock.Any(), resourceID).
        Return(nil, domain.ErrNotFound)
    
    return svc
}
```

## Response Comparison

### Exact Comparison
For responses with fully predictable data:
```go
if !cmp.Equal(gotResp, tt.wantResp) {
    t.Errorf("handler() resp = %v, want %v, diff %v", gotResp, tt.wantResp, cmp.Diff(gotResp, tt.wantResp))
}

if !cmp.Equal(gotErrResp, tt.wantErrResp, cmpopts.EquateErrors()) {
    t.Errorf("handler() err resp = %v, want %v, diff %v", gotErrResp, tt.wantErrResp, cmp.Diff(gotErrResp, tt.wantErrResp, cmpopts.EquateErrors()))
}
```

### Comparison with Custom Options
For responses with dynamic fields (UUIDs, timestamps):
```go
opts := cmp.Options{
    cmp.Comparer(func(a, b *CreateResourceResponse) bool {
        // Only verify that UUIDs are not nil
        return a != nil && b != nil && a.ID != uuid.Nil && b.ID != uuid.Nil
    }),
}

if !cmp.Equal(gotResp, tt.wantResp, opts) {
    t.Errorf("handler() resp = %v, want %v, diff %v", gotResp, tt.wantResp, cmp.Diff(gotResp, tt.wantResp, opts))
}
```

### Length-Only Comparison
For list responses where exact content varies:
```go
opts := cmp.Options{
    cmp.Comparer(func(a, b *ListResourcesResponse) bool {
        return a != nil && b != nil && len(a.Resources) == len(b.Resources)
    }),
}

if !cmp.Equal(gotResp, tt.wantResp, opts) {
    t.Errorf("handler() resp = %v, want %v, diff %v", gotResp, tt.wantResp, cmp.Diff(gotResp, tt.wantResp, opts))
}
```

### Error Response Comparison
**ALWAYS** use `cmpopts.EquateErrors()` when comparing error responses:
```go
if !cmp.Equal(gotErrResp, tt.wantErrResp, cmpopts.EquateErrors()) {
    t.Errorf("handler() err resp = %v, want %v, diff %v", gotErrResp, tt.wantErrResp, cmp.Diff(gotErrResp, tt.wantErrResp, cmpopts.EquateErrors()))
}
```

## Custom Matchers

### When to Use Custom Matchers
Use custom matchers for parameter validation when:
1. Parameters contain dynamic values (timestamps, generated UUIDs)
2. Parameters are complex structs with many fields
3. You need to validate specific fields while ignoring others

### Custom Matcher Implementation
```go
// Define matcher type
type createChannelParamsMatcher struct {
    params *channel.CreateChannelParams
}

// Implement Matches method
func (m createChannelParamsMatcher) Matches(x interface{}) bool {
    p, ok := x.(*channel.CreateChannelParams)
    if !ok {
        return false
    }

    // Validate specific fields
    return p.ID != uuid.Nil &&
        p.UserID == m.params.UserID &&
        p.Name == m.params.Name &&
        p.Icon == m.params.Icon &&
        p.Description == m.params.Description &&
        cmp.Equal(p.Wallets, m.params.Wallets) &&
        !p.AfterTime.IsZero() &&
        !p.CreatedAt.IsZero()
}

// Implement String method for error messages
func (m createChannelParamsMatcher) String() string {
    return fmt.Sprintf("%+v", m.params)
}
```

### Using Custom Matcher
```go
svc.EXPECT().
    CreateChannel(gomock.Any(), createChannelParamsMatcher{params: &channel.CreateChannelParams{
        UserID:      userID,
        Name:        "test",
        Icon:        "icon",
        Description: "description",
        Wallets:     []string{"address"},
    }}).
    Return(nil)
```

## Helper Functions

### URL Parameter Helper
**MANDATORY**: Define this helper at the end of test file:
```go
// Helper function to create request with chi URL parameters.
func createRequestWithURLParam(method, url, paramValue string) *http.Request {
    req := httptest.NewRequest(method, url, nil)
    rctx := chi.NewRouteContext()
    rctx.URLParams.Add("id", paramValue)
    req = req.WithContext(context.WithValue(req.Context(), chi.RouteCtxKey, rctx))

    return req
}
```

### Pointer Helper Functions
For creating pointers to values in test data:
```go
// Helper function to create string pointer.
func stringPtr(s string) *string {
    return &s
}

// Helper function to create decimal pointer.
func decimalPtr(d decimal.Decimal) *decimal.Decimal {
    return &d
}

// Helper function to create int pointer.
func intPtr(i int) *int {
    return &i
}
```

### Usage of Pointer Helpers
```go
wantResp: &httpwrap.Response{
    StatusCode: http.StatusOK,
    Body: &ResourceResponse{
        ID:          resourceID,
        Name:        "test",
        MaxLimit:    intPtr(100),
        Description: stringPtr("test description"),
        Price:       decimalPtr(decimal.NewFromFloat(99.99)),
    },
}
```

## Test Case Patterns

### Success Case
```go
{
    name: "success",
    setupReq: func() *http.Request {
        req := httptest.NewRequest(http.MethodGet, "/resources", nil)
        req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
        return req
    },
    setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
        svc := mocks.NewMockService(ctrl)
        
        svc.EXPECT().
            GetResources(gomock.Any(), userID).
            Return([]*domain.Resource{{ID: resourceID}}, nil)
        
        return svc
    },
    wantResp: &httpwrap.Response{
        StatusCode: http.StatusOK,
        Body: &ListResourcesResponse{
            Resources: []*ResourceResponse{{ID: resourceID}},
        },
    },
}
```

### Not Found Error Case
```go
{
    name: "error - resource not found",
    setupReq: func() *http.Request {
        req := createRequestWithURLParam(
            http.MethodGet,
            fmt.Sprintf("/resources/%s", resourceID.String()),
            resourceID.String(),
        )
        req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
        return req
    },
    setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
        svc := mocks.NewMockService(ctrl)
        
        svc.EXPECT().
            GetResource(gomock.Any(), resourceID).
            Return(nil, domain.ErrNotFound)
        
        return svc
    },
    wantErrResp: &httpwrap.ErrorResponse{
        StatusCode: http.StatusNotFound,
        ErrorMsg:   domain.ErrNotFound.Error(),
        Err:        domain.ErrNotFound,
    },
}
```

### Service Error Case
```go
{
    name: "error - service fails",
    setupReq: func() *http.Request {
        req := httptest.NewRequest(http.MethodPost, "/resources", nil)
        req.Body = io.NopCloser(bytes.NewReader([]byte(`{"name": "test"}`)))
        req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
        return req
    },
    setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
        svc := mocks.NewMockService(ctrl)
        
        svc.EXPECT().
            CreateResource(gomock.Any(), gomock.Any()).
            Return(nil, errDatabase)
        
        return svc
    },
    wantErrResp: &httpwrap.ErrorResponse{
        StatusCode: http.StatusInternalServerError,
        ErrorMsg:   "database error",
        Err:        errDatabase,
    },
}
```

### Invalid Parameter Case
```go
{
    name: "error - invalid id parameter",
    setupReq: func() *http.Request {
        req := createRequestWithURLParam(
            http.MethodGet,
            "/resources/invalid-uuid",
            "invalid-uuid",
        )
        return req
    },
    setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
        // No expectations - handler should fail before calling service
        return mocks.NewMockService(ctrl)
    },
    wantErrResp: &httpwrap.ErrorResponse{
        StatusCode: http.StatusBadRequest,
        ErrorMsg:   "invalid param: id",
    },
}
```

### Idempotent Delete Case
```go
{
    name: "success - resource not found (idempotent)",
    setupReq: func() *http.Request {
        req := createRequestWithURLParam(
            http.MethodDelete,
            fmt.Sprintf("/resources/%s", resourceID.String()),
            resourceID.String(),
        )
        return req
    },
    setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
        svc := mocks.NewMockService(ctrl)
        
        // DELETE is idempotent - return success even if not found
        svc.EXPECT().
            DeleteResource(gomock.Any(), resourceID).
            Return(domain.ErrNotFound)
        
        return svc
    },
    wantResp: &httpwrap.Response{
        StatusCode: http.StatusOK,
    },
}
```

### Edge Cases
```go
// Empty list
{
    name: "success - empty list",
    setupReq: func() *http.Request {
        req := httptest.NewRequest(http.MethodGet, "/resources", nil)
        req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
        return req
    },
    setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
        svc := mocks.NewMockService(ctrl)
        
        svc.EXPECT().
            ListResources(gomock.Any(), userID).
            Return([]*domain.Resource{}, nil) // Empty slice
        
        return svc
    },
    wantResp: &httpwrap.Response{
        StatusCode: http.StatusOK,
        Body: &ListResourcesResponse{
            Resources: []*ResourceResponse{},
        },
    },
}

// Multiple items
{
    name: "success - multiple resources",
    setupReq: func() *http.Request {
        req := httptest.NewRequest(http.MethodGet, "/resources", nil)
        req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
        return req
    },
    setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
        svc := mocks.NewMockService(ctrl)
        
        resources := []*domain.Resource{
            {ID: uuid.New(), Name: "resource1"},
            {ID: uuid.New(), Name: "resource2"},
            {ID: uuid.New(), Name: "resource3"},
        }
        
        svc.EXPECT().
            ListResources(gomock.Any(), userID).
            Return(resources, nil)
        
        return svc
    },
    wantResp: &httpwrap.Response{
        StatusCode: http.StatusOK,
        Body: &ListResourcesResponse{
            Resources: []*ResourceResponse{
                {ID: uuid.New(), Name: "resource1"},
                {ID: uuid.New(), Name: "resource2"},
                {ID: uuid.New(), Name: "resource3"},
            },
        },
    },
}
```

## Test Constants

### Define at Function Level
```go
func Test_handlerName(t *testing.T) {
    t.Parallel()

    // Define test UUIDs
    userID := uuid.New()
    resourceID := uuid.New()
    itemID := uuid.New()

    // Define test times
    baseTime := time.Unix(1700000000, 0).UTC()

    // Define test decimals
    minPrice := decimal.NewFromFloat(100.0)
    maxPrice := decimal.NewFromFloat(1000.0)

    tests := []struct {
        // ...
    }
}
```

## Testing Different HTTP Methods

### POST (Create)
```go
setupReq: func() *http.Request {
    req := httptest.NewRequest(http.MethodPost, "/resources", nil)
    req.Body = io.NopCloser(bytes.NewReader([]byte(`{"name": "test"}`)))
    req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
    return req
}
```

### GET (Retrieve)
```go
// Single resource
setupReq: func() *http.Request {
    req := createRequestWithURLParam(
        http.MethodGet,
        fmt.Sprintf("/resources/%s", resourceID.String()),
        resourceID.String(),
    )
    req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
    return req
}

// List resources
setupReq: func() *http.Request {
    req := httptest.NewRequest(http.MethodGet, "/resources", nil)
    req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
    return req
}
```

### PUT (Update/Add)
```go
setupReq: func() *http.Request {
    req := createRequestWithURLParam(
        http.MethodPut,
        fmt.Sprintf("/resources/%s", resourceID.String()),
        resourceID.String(),
    )
    req.Body = io.NopCloser(bytes.NewReader([]byte(`{"name": "updated"}`)))
    req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
    return req
}
```

### DELETE (Remove)
```go
setupReq: func() *http.Request {
    req := createRequestWithURLParam(
        http.MethodDelete,
        fmt.Sprintf("/resources/%s", resourceID.String()),
        resourceID.String(),
    )
    req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
    return req
}
```

## Common Testing Patterns

### Testing with Context Values
```go
// Set user ID in context
req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))

// Set other context values
ctx := context.WithValue(req.Context(), "key", "value")
req = req.WithContext(ctx)
```

### Testing Time-Sensitive Operations
```go
setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
    svc := mocks.NewMockService(ctrl)
    
    // Use gomock.Any() for timestamps since they're generated dynamically
    svc.EXPECT().
        CreateResource(gomock.Any(), gomock.Any()).
        Do(func(ctx context.Context, params *domain.CreateParams) {
            // Validate that timestamp is recent (within last second)
            if time.Since(params.CreatedAt) > time.Second {
                panic("timestamp is not recent")
            }
        }).
        Return(nil)
    
    return svc
}
```

### Testing Map Responses
```go
wantResp: &httpwrap.Response{
    StatusCode: http.StatusOK,
    Body: &LookupResponse{
        Items: map[string]*Item{
            "key1": {ID: uuid.New(), Name: "item1"},
            "key2": {ID: uuid.New(), Name: "item2"},
        },
    },
}
```

## Best Practices

1. **Use setupReq and setupSvc functions**: Keep test structure consistent
2. **Preallocate test data**: Define UUIDs and constants at function level
3. **Use helper functions**: Avoid duplicating URL param setup code
4. **Use custom matchers**: For complex parameter validation
5. **Test all error paths**: Cover domain errors, validation errors, service errors
6. **Use static error variables**: Define at package level for reuse
7. **Compare with proper options**: Use cmp.Options for dynamic fields
8. **Always use cmpopts.EquateErrors()**: When comparing error responses
9. **Test edge cases**: Empty lists, multiple items, nil values
10. **Keep tests focused**: One scenario per test case
11. **Use descriptive names**: Follow go-testing-guide.mdc naming conventions
12. **Validate request setup**: Ensure context values are set correctly

## Complete Example

```go
func Test_createChannel(t *testing.T) {
    t.Parallel()

    userID := uuid.New()

    tests := []struct {
        name        string
        setupReq    func() *http.Request
        setupSvc    func(ctrl *gomock.Controller) *mocks.MockService
        wantResp    *httpwrap.Response
        wantErrResp *httpwrap.ErrorResponse
    }{
        {
            name: "success",
            setupReq: func() *http.Request {
                req := httptest.NewRequest(http.MethodPost, "/channels", nil)
                req.Body = io.NopCloser(bytes.NewReader([]byte(`{
                    "name": "test",
                    "icon": "icon",
                    "description": "description",
                    "wallets": ["address"]
                }`)))
                req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
                return req
            },
            setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
                svc := mocks.NewMockService(ctrl)

                svc.EXPECT().ListChannelsByUserID(gomock.Any(), userID).Return(nil, nil)
                svc.EXPECT().CreateChannel(gomock.Any(), gomock.Any()).Return(nil)

                return svc
            },
            wantResp: &httpwrap.Response{
                StatusCode: http.StatusOK,
                Body: &CreateChannelResponse{
                    ID: uuid.New(),
                },
            },
        },
        {
            name: "error - user already has channel",
            setupReq: func() *http.Request {
                req := httptest.NewRequest(http.MethodPost, "/channels", nil)
                req.Body = io.NopCloser(bytes.NewReader([]byte(`{
                    "name": "test",
                    "icon": "icon",
                    "description": "description"
                }`)))
                req = req.WithContext(middleware.SetUserID(req.Context(), userID.String()))
                return req
            },
            setupSvc: func(ctrl *gomock.Controller) *mocks.MockService {
                svc := mocks.NewMockService(ctrl)

                existingChannel := &channel.Channel{
                    ID:   uuid.New(),
                    Name: "existing",
                }
                svc.EXPECT().ListChannelsByUserID(gomock.Any(), userID).Return([]*channel.Channel{existingChannel}, nil)

                return svc
            },
            wantErrResp: &httpwrap.ErrorResponse{
                StatusCode: http.StatusBadRequest,
                ErrorMsg:   channel.ErrUserChannelLimit.Error(),
                Err:        channel.ErrUserChannelLimit,
            },
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()

            ctrl := gomock.NewController(t)
            req := tt.setupReq()

            gotResp, gotErrResp := createChannel(tt.setupSvc(ctrl))(req)

            opts := cmp.Options{
                cmp.Comparer(func(a, b *CreateChannelResponse) bool {
                    return a != nil && b != nil && a.ID != uuid.Nil && b.ID != uuid.Nil
                }),
            }

            if !cmp.Equal(gotResp, tt.wantResp, opts) {
                t.Errorf("createChannel() resp = %v, want %v, diff %v", gotResp, tt.wantResp, cmp.Diff(gotResp, tt.wantResp, opts))
            }

            if !cmp.Equal(gotErrResp, tt.wantErrResp, cmpopts.EquateErrors()) {
                t.Errorf("createChannel() err resp = %v, want %v, diff %v", gotErrResp, tt.wantErrResp, cmp.Diff(gotErrResp, tt.wantErrResp, cmpopts.EquateErrors()))
            }
        })
    }
}
```
